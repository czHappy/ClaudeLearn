# GESP C++ 六级真题详解 (2025年09月)

## 答案速查表

### 单选题答案
| 题号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|------|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|
| 答案 | D | A | C | B | A | B | A | A | B | B  | D  | A  | A  | C  | D  |

### 判断题答案
| 题号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|------|---|---|---|---|---|---|---|---|---|----|
| 答案 | √ | × | × | × | √ | √ | √ | √ | × | √  |

---

## 一、单选题详解（每题2分，共30分）

### 第1题 - 虚函数与析构函数（答案：D）

**题目分析**：
本题考查C++类的高级特性，特别是虚函数和多态的理解。

**选项分析**：
- **A. 构造函数不能声明为虚函数，但析构函数可以** ✓ **正确**
  - 构造函数不能是虚函数，因为创建对象时类型已确定
  - 析构函数应该声明为虚函数，防止内存泄漏

- **B. 函数参数如声明为类的引用类型，调用时不会调用该类的复制构造函数** ✓ **正确**
  - 引用传递不会创建副本，所以不调用复制构造函数

- **C. 静态方法属于类而不是某个具体对象，因此推荐用 类名::方法(...) 调用** ✓ **正确**
  - 静态方法是类级别的，用类名调用更清晰

- **D. 不管基类的析构函数是否是虚函数，都可以通过基类指针/引用正确删除派生类对象** ✗ **错误**
  - **这是错误的！** 如果基类析构函数不是虚函数，通过基类指针删除派生类对象会导致**未定义行为**
  - 只有派生类独有的资源会泄漏，基类部分会被析构

**知识点**：
1. **虚析构函数的必要性**
2. **引用传递与复制构造**
3. **静态成员函数**
4. **多态与虚函数表**

**示例代码**：
```cpp
class Base {
public:
    ~Base() { cout << "~Base()" << endl; }  // 非虚析构
};

class Derived : public Base {
    int* data;
public:
    Derived() { data = new int[100]; }
    ~Derived() {
        delete[] data;  // 不会被调用！
        cout << "~Derived()" << endl;
    }
};

int main() {
    Base* p = new Derived();
    delete p;  // 只调用 ~Base()，内存泄漏！
}
```

**正确做法**：
```cpp
class Base {
public:
    virtual ~Base() { cout << "~Base()" << endl; }  // 虚析构
};
```

---

### 第2题 - 继承性质（答案：A）

**题目分析**：
题目中 `Car` 类继承自 `Vehicle` 类，因此 `Car` 类的对象 `veh` 可以调用从 `Vehicle` 继承来的 `move()` 方法。

**知识点**：
- **继承（Inheritance）**：派生类可以使用基类的公有成员
- 封装：隐藏内部实现
- 多态：相同接口不同行为
- 链接：不是OOP概念

**答案**：**A. 继承 (Inheritance)**

---

### 第3题 - 多态性质（答案：C）

**题目分析**：
- `v1` 和 `v2` 都是 `Vehicle*` 类型的基类指针
- 分别指向 `Car` 和 `Bike` 对象
- 调用相同的 `move()` 接口，但输出不同结果
- 关键：`move()` 被声明为 `virtual`，并在派生类中 `override`

**代码分析**：
```cpp
Vehicle* v1 = new Car("Toyota", 5);   // 基类指针指向派生类对象
Vehicle* v2 = new Bike("Giant");

v1->move();  // 输出: Toyota car is driving on the road!
v2->move();  // 输出: Giant bike is cycling on the path!
```

**知识点**：
1. **多态（Polymorphism）**：通过虚函数实现运行时多态
2. **虚函数表（vtable）**：实现动态绑定
3. **override 关键字**：明确表示重写虚函数

**答案**：**C. 多态 (Polymorphism)**

---

### 第4题 - 栈的操作特点（答案：B）

**题目分析**：
栈（Stack）是一种基本数据结构，遵循特定的访问规则。

**选项分析**：
- A. 先进先出 ✗ 这是**队列（Queue）**的特点
- **B. 先进后出 ✓** 正确，这是栈的核心特点
- C. 随机访问 ✗ 栈不支持随机访问
- D. 双端进出 ✗ 这是**双端队列（Deque）**的特点

**知识点**：
- **LIFO (Last In First Out)**：后进先出
- 栈的操作：`push`（入栈）、`pop`（出栈）、`top`（查看栈顶）
- 栈的应用：函数调用栈、表达式求值、括号匹配

**图示**：
```
push(1) → push(2) → push(3) → pop() 返回 3

栈的状态变化：
[]  →  [1]  →  [1,2]  →  [1,2,3]  →  [1,2]
                           ↑栈顶
```

**答案**：**B. 先进后出**

---

### 第5题 - 循环队列操作（答案：A）

**题目分析**：
循环队列容量为5，留一个空位区分空和满，实际可存4个元素。

**操作过程**：
```
初始状态：队列空 []
          front=0, rear=0

入队 1：[1, _, _, _, _]
       front=0, rear=1

入队 2：[1, 2, _, _, _]
       front=0, rear=2

入队 3：[1, 2, 3, _, _]
       front=0, rear=3

出队 1：[_, 2, 3, _, _]  // 删除元素1
       front=1, rear=3

入队 4：[_, 2, 3, 4, _]
       front=1, rear=4

入队 5：[_, 2, 3, 4, 5]  // 循环使用
       front=1, rear=0（循环到开头）

队首到队尾：[2, 3, 4, 5]
```

**知识点**：
1. **循环队列**：使用模运算实现循环
2. **空满判断**：
   - 空：`front == rear`
   - 满：`(rear + 1) % capacity == front`
3. **留空位策略**：防止空满判断冲突

**答案**：**A. [2, 3, 4, 5]**

---

### 第6题 - 二叉树类型识别（答案：B）

**题目分析**：
观察 `createTree()` 函数构造的树结构：

```
      1
     / \
    2   3
   / \
  4   5
```

**树的类型判断**：
- **满二叉树**：每层节点数都达到最大（2^层数）
  - 本树第3层只有2个节点，不是满的 ✗

- **完全二叉树**：除最后一层外，其他层都是满的；最后一层从左到右连续
  - 第2层：满的（2个节点）✓
  - 第3层：从左到右连续（4, 5）✓
  - **符合定义！** ✓

- **二叉排序树（BST）**：左子树 < 根 < 右子树
  - 节点2的左子树4 > 2 ✗ 不符合

**完全二叉树的性质**：
1. 可以用数组高效存储
2. 节点编号规律：
   - 父节点 i，左孩子 2i，右孩子 2i+1
3. 堆就是完全二叉树

**答案**：**B. 完全二叉树**

---

### 第7题 - 二叉树遍历推导（答案：A）

**题目分析**：
- **中序遍历**：`[D, B, E, A, F, C]`
- **先序遍历**：`[A, B, D, E, C, F]`
- 求：**后序遍历**

**推导过程**：

**步骤1：从先序确定根节点**
- 先序第一个是根：**A**

**步骤2：从中序划分左右子树**
```
中序：[D, B, E, A, F, C]
       -------  -----
       左子树A   右子树A
```

**步骤3：递归构建左子树**
- 左子树的先序：`[B, D, E]` → 根是 **B**
- 左子树的中序：`[D, B, E]` → D在B左边，E在B右边

```
    B
   / \
  D   E
```

**步骤4：递归构建右子树**
- 右子树的先序：`[C, F]` → 根是 **C**
- 右子树的中序：`[F, C]` → F在C左边

```
    C
   /
  F
```

**步骤5：合成完整树**
```
      A
     / \
    B   C
   / \  /
  D  E F
```

**步骤6：后序遍历（左-右-根）**
- 遍历B的左子树：D
- 遍历B的右子树：E
- 访问B：D, E, B
- 遍历C的左子树：F
- 访问C：F, C
- 访问A：D, E, B, F, C, A

**知识点**：
1. **先序遍历**：根-左-右（确定根节点）
2. **中序遍历**：左-根-右（划分左右子树）
3. **后序遍历**：左-右-根
4. **树的重建**：先序+中序 或 后序+中序 可唯一确定树

**答案**：**A. [D, E, B, F, C, A]**

---

### 第8题 - 完全二叉树的数组表示（答案：A）

**题目分析**：
完全二叉树从编号1开始存储在数组中，节点编号规律如下：

**数组存储示例**：
```
数组索引：   1   2   3   4   5   6   7
节点值：    [A] [B] [C] [D] [E] [F] [G]

树形结构：
         A(1)
        /    \
      B(2)    C(3)
     /  \    /  \
   D(4) E(5)F(6) G(7)
```

**父子节点关系**（编号从1开始）：
- 节点 i 的**左孩子**：`2i`
- 节点 i 的**右孩子**：`2i + 1`
- 节点 i 的**父节点**：`⌊i/2⌋`

**验证**：
- 节点2的左孩子：2×2 = 4 ✓
- 节点2的右孩子：2×2+1 = 5 ✓
- 节点3的左孩子：2×3 = 6 ✓
- 节点3的右孩子：2×3+1 = 7 ✓

**选项分析**：
- **A. 左孩子位于 2i，右孩子位于 2i+1** ✓ **正确**
- B. 完全二叉树的叶子节点可以出现在最后一层的任意位置 ✗ 必须从左到右连续
- C. 所有节点都有两个孩子 ✗ 叶子节点没有孩子
- D. 左孩子位于 2i+1，右孩子位于 2i+2 ✗ 这是编号从0开始的情况

**知识点**：
1. **完全二叉树的性质**
2. **数组存储优势**：空间利用率高，访问父子节点快速
3. **堆的实现**：基于完全二叉树的数组表示

**答案**：**A. 左孩子位于 2i，右孩子位于 2i+1**

---

### 第9题 - 哈夫曼编码（答案：B）

**题目分析**：
字符集：`{a, b, c, d, e, f}`
频率：`{5, 9, 12, 13, 16, 45}`

**哈夫曼编码原理**：
1. 频率低的字符编码长
2. 频率高的字符编码短
3. 前缀码：任何编码都不是其他编码的前缀

**构建哈夫曼树过程**：
```
初始：a:5, b:9, c:12, d:13, e:16, f:45

步骤1：合并a(5)和b(9) → 14
      [14, c:12, d:13, e:16, f:45]

步骤2：合并c(12)和d(13) → 25
      [14, 25, e:16, f:45]

步骤3：合并14和e(16) → 30
      [25, 30, f:45]

步骤4：合并25和30 → 55
      [55, f:45]

步骤5：合并55和45 → 100
      [100]
```

**编码长度分析**：
- f(45)：最高频率，应该编码最短（1位）
- a(5)：最低频率，应该编码最长（4位）
- 编码长度应该递减：a > b > c ≈ d ≈ e > f

**选项验证**：
- A. f:0 (1位)✓, a:00(2位)✗ **太短**
- **B. f:0 (1位)✓, a:1100(4位)✓, b:1101(4位)✓** **符合！**
- C. f:111(3位)✗ **太长**
- D. f:0 (1位)✓, a:10(2位)✗ **太短**

**带权路径长度计算**（选项B）：
```
WPL = 5×4 + 9×4 + 12×3 + 13×3 + 16×3 + 45×1
    = 20 + 36 + 36 + 39 + 48 + 45
    = 224
```

**知识点**：
1. **哈夫曼编码算法**：贪心算法
2. **前缀码性质**
3. **WPL最优性**：哈夫曼编码是最优前缀码
4. **应用**：数据压缩（ZIP、JPEG等）

**答案**：**B. a: 1100；b: 1101；c: 100；d: 101；e: 111；f: 0**

---

### 第10题 - 格雷码生成（答案：B）

**题目分析**：
格雷码（Gray Code）的特点是相邻两个数只有一位不同。

**生成规律**（递归）：
```
n=1: ["0", "1"]

n=2:
  前半部分：在n=1前加"0" → ["00", "01"]
  后半部分：在n=1反序前加"1" → ["11", "10"]
  结果：["00", "01", "11", "10"]

n=3:
  前半部分：["000", "001", "011", "010"]
  后半部分：["110", "111", "101", "100"]  ← 注意是反序！
```

**代码分析**：
```cpp
// 前半部分：顺序加"0"
for (string s : prev) {
    result.push_back("0" + s);
}

// 后半部分：需要反序加"1"
for (_______________) {  // 填空
    result.push_back("1" + prev[i]);
}
```

**选项分析**：
- A. `int i = 0; i < prev.size(); i++` ✗ 正序遍历
- **B. `int i = prev.size()-1; i >= 0; i--` ✓ 反序遍历**
- C. `auto s : prev` ✗ 正序遍历
- D. `int i = prev.size()/2; i < prev.size(); i++` ✗ 只遍历后半部分

**格雷码的性质**：
1. 相邻编码只有一位不同
2. 首尾也只有一位不同（循环格雷码）
3. 应用：旋转编码器、卡诺图化简

**答案**：**B. int i = prev.size()-1; i >= 0; i--**

---

### 第11题 - 深度优先遍历容器（答案：D）

**题目分析**：
深度优先遍历（DFS）使用**栈（Stack）**实现。

**代码分析**：
```cpp
void dfs(TreeNode* root) {
    ______<TreeNode*> temp;  // 填空
    temp.push(root);

    while (!temp.empty()) {
        TreeNode* node = temp.top();  // 取栈顶
        temp.pop();                    // 出栈

        // 先压右孩子，后压左孩子
        // 这样先访问左孩子（栈是后进先出）
        if (node->right) temp.push(node->right);
        if (node->left) temp.push(node->left);
    }
}
```

**为什么使用栈？**
- DFS 需要"深入"探索，然后"回溯"
- 栈的 LIFO 特性完美契合这个过程
- 递归实现 DFS 其实就是利用系统调用栈

**容器对比**：
| 容器 | 特点 | 适用场景 |
|------|------|---------|
| stack | 后进先出 | DFS |
| queue | 先进先出 | BFS |
| vector | 随机访问 | 存储序列 |
| list | 双向链表 | 频繁插入删除 |

**DFS vs BFS**：
```
     1
    / \
   2   3
  / \
 4   5

DFS(栈)：1 → 2 → 4 → 5 → 3
BFS(队列)：1 → 2 → 3 → 4 → 5
```

**答案**：**D. stack**

---

### 第12题 - BFS时间复杂度（答案：A）

**题目分析**：
广度优先遍历（BFS）使用队列实现，分析其时间复杂度。

**代码分析**：
```cpp
void bfs(TreeNode* root) {
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {          // 外层循环
        TreeNode* node = q.front();
        q.pop();
        cout << node->val << " ";

        if (node->left) q.push(node->left);    // 每个节点访问一次
        if (node->right) q.push(node->right);
    }
}
```

**复杂度分析**：
- **每个节点入队一次**：O(n)
- **每个节点出队一次**：O(n)
- **每个节点处理一次**：O(n)
- **总时间复杂度**：**O(n)**

**n 是树的节点总数**

**为什么不是其他选项？**
- B. O(log n) ✗ 这是平衡树的高度
- C. O(n²) ✗ 没有嵌套遍历
- D. O(2^n) ✗ 不是指数级

**BFS的特点**：
1. 逐层遍历
2. 可以找到最短路径
3. 空间复杂度：O(w)，w是最大宽度

**答案**：**A. O(n)**

---

### 第13题 - 二叉搜索树查找（答案：A）

**题目分析**：
在二叉搜索树（BST）中查找元素50，当前根节点值为60。

**BST的性质**：
- **左子树的所有值 < 根节点**
- **右子树的所有值 > 根节点**

**查找逻辑**：
```
当前节点：60
目标值：50

比较：50 < 60
结论：目标在左子树
```

**BST查找算法**：
```cpp
TreeNode* search(TreeNode* root, int target) {
    if (!root || root->val == target) return root;

    if (target < root->val)
        return search(root->left, target);   // 去左子树
    else
        return search(root->right, target);  // 去右子树
}
```

**时间复杂度**：
- 平衡BST：O(log n)
- 退化成链：O(n)

**答案**：**A. 左子树**

---

### 第14题 - BST删除节点（答案：C）

**题目分析**：
删除BST中有两个孩子的节点，有两种经典策略。

**删除策略**：
1. **找左子树的最大值**（前驱）替换当前节点
2. **找右子树的最小值**（后继）替换当前节点

**代码分析**：
```cpp
else {  // 有两个孩子
    if (!root->left) return root->right;
    if (!root->right) return root->left;

    TreeNode* temp = ____________;  // 填空
    root->val = temp->val;
    root->right = deleteNode(root->right, temp->val);
}
```

**从代码看**：
- 最后一行：`root->right = deleteNode(root->right, temp->val)`
- 说明在**右子树**中删除 temp
- 因此 temp 应该是**右子树的最小值**

**选项分析**：
- A. root->left ✗ 整个左子树
- B. root->right ✗ 整个右子树
- **C. findMin(root->right) ✓ 右子树的最小值（后继）**
- D. findMax(root->left) ✗ 应该配合左子树删除

**为什么用后继/前驱？**
- 保持BST性质
- 后继是右子树最小值，大于左子树所有值
- 前驱是左子树最大值，小于右子树所有值

**图示**：
```
删除节点50（有两个孩子）：

     50                60
    /  \      →       /  \
   30   70           30   70
       /  \              \
      60   80             80

策略：用右子树最小值(60)替换50，然后删除60
```

**答案**：**C. findMin(root->right)**

---

### 第15题 - 0-1背包动态规划（答案：D）

**题目分析**：
经典的0-1背包问题，每个物品只能选择一次。

**状态定义**：
- `dp[w]`：容量为w时的最大价值

**代码分析**：
```cpp
for (int i = 0; i < n; ++i) {           // 遍历物品
    for (int w = W; w >= wt[i]; --w) {  // 从大到小遍历容量
        ________________________         // 状态转移方程
    }
}
```

**状态转移**：
对于物品i和容量w，有两种选择：
1. **不选物品i**：`dp[w]` 保持不变
2. **选物品i**：`dp[w - wt[i]] + val[i]`（需要w >= wt[i]）

取两者最大值：
```cpp
dp[w] = max(dp[w], dp[w - wt[i]] + val[i]);
```

**为什么从大到小遍历？**
- 保证每个物品只用一次
- 更新 `dp[w]` 时，`dp[w - wt[i]]` 还没更新，是上一轮的值
- 如果从小到大，可能用同一物品多次（变成完全背包）

**选项分析**：
- A. `dp[w] = max(dp[w], dp[w] + val[i])` ✗ 重复累加
- B. `dp[w] = dp[w - wt[i]] + val[i]` ✗ 没有max，强制选择
- C. `dp[w] = max(dp[w - 1], dp[w - wt[i]] + val[i])` ✗ dp[w-1]无意义
- **D. `dp[w] = max(dp[w], dp[w - wt[i]] + val[i])` ✓ 正确**

**0-1背包 vs 完全背包**：
```cpp
// 0-1背包（每个物品用一次）
for (int i = 0; i < n; i++)
    for (int w = W; w >= wt[i]; w--)  // 从大到小
        dp[w] = max(dp[w], dp[w - wt[i]] + val[i]);

// 完全背包（每个物品无限次）
for (int i = 0; i < n; i++)
    for (int w = wt[i]; w <= W; w++)  // 从小到大
        dp[w] = max(dp[w], dp[w - wt[i]] + val[i]);
```

**答案**：**D. dp[w] = max(dp[w], dp[w - wt[i]] + val[i])**

---

## 二、判断题详解（每题2分，共20分）

### 第1题 - 虚析构函数（答案：√）

**题目**：当基类可能被多态使用，其析构函数应该声明为虚函数。

**分析**：
- **正确！** 这是C++多态的最佳实践
- 如果通过基类指针删除派生类对象，需要虚析构函数确保调用派生类的析构

**示例**：
```cpp
class Base {
public:
    virtual ~Base() {}  // 虚析构函数
};

class Derived : public Base {
    int* data;
public:
    Derived() { data = new int[100]; }
    ~Derived() { delete[] data; }  // 会被正确调用
};

int main() {
    Base* p = new Derived();
    delete p;  // 正确：调用 ~Derived() 然后 ~Base()
}
```

**答案**：**√（正确）**

---

### 第2题 - 哈夫曼编码唯一性（答案：×）

**题目**：哈夫曼编码是最优前缀码，且编码结果唯一。

**分析**：
- **前半句正确**：哈夫曼编码是最优前缀码（WPL最小）
- **后半句错误**：编码结果**不唯一**！

**为什么不唯一？**
1. 构造哈夫曼树时，频率相同的节点合并顺序不确定
2. 左右分支可以互换（0变1，1变0）
3. 多种树结构可能有相同的WPL

**示例**：
```
字符：a, b, c
频率：1, 1, 2

可能的编码1：       可能的编码2：
    *                  *
   / \                / \
  c   *              *   c
     / \            / \
    a   b          b   a

a:10, b:11, c:0    a:01, b:00, c:1
```

两种编码都是最优的，WPL都是4。

**答案**：**×（错误）**

---

### 第3题 - 完全二叉树高度（答案：×）

**题目**：一个含有n个节点的完全二叉树，高度为⌈log₂n⌉。

**分析**：
- **错误！** 应该是 **⌊log₂n⌋ + 1** 或 **⌈log₂(n+1)⌉**

**正确公式**：
- **高度定义1**（从1开始）：h = ⌊log₂n⌋ + 1
- **高度定义2**（从0开始）：h = ⌊log₂n⌋

**验证**：
```
n=1: 高度=1, ⌈log₂1⌉=0 ✗, ⌊log₂1⌋+1=1 ✓
n=3: 高度=2, ⌈log₂3⌉=2 ✓ 偶然对
n=4: 高度=3, ⌈log₂4⌉=2 ✗, ⌊log₂4⌋+1=3 ✓
```

**树的高度定义**：
- **高度**：从根到叶子的最长路径的**边数**
- **深度**：同高度
- 有的书定义根节点高度为1，有的为0

**答案**：**×（错误）**

---

### 第4题 - STL栈的pop操作（答案：×）

**题目**：在C++ STL中，栈（std::stack）的pop操作返回栈顶元素并移除它。

**分析**：
- **错误！** `pop()` **不返回值**，只移除栈顶元素

**正确用法**：
```cpp
#include <stack>
using namespace std;

stack<int> s;
s.push(10);
s.push(20);

// 错误用法：
// int val = s.pop();  // 编译错误！pop()返回void

// 正确用法：
int val = s.top();  // 先获取栈顶
s.pop();            // 再移除
```

**为什么这样设计？**
1. **异常安全**：如果pop返回值，拷贝可能抛异常，导致元素丢失
2. **效率**：分离top和pop，避免不必要的拷贝
3. **设计哲学**：一个函数只做一件事

**STL容器操作对比**：
```cpp
stack<int> s;
s.top();   // 返回栈顶，不移除
s.pop();   // 移除栈顶，不返回

queue<int> q;
q.front(); // 返回队首，不移除
q.pop();   // 移除队首，不返回
```

**答案**：**×（错误）**

---

### 第5题 - 循环队列模运算（答案：√）

**题目**：循环队列通过模运算循环使用空间。

**分析**：
- **正确！** 这是循环队列的核心实现方式

**循环队列实现**：
```cpp
class CircularQueue {
    int* data;
    int front, rear;
    int capacity;

public:
    CircularQueue(int k) : capacity(k+1) {
        data = new int[capacity];
        front = rear = 0;
    }

    bool enQueue(int value) {
        if (isFull()) return false;
        data[rear] = value;
        rear = (rear + 1) % capacity;  // 模运算循环
        return true;
    }

    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % capacity;  // 模运算循环
        return true;
    }

    bool isEmpty() { return front == rear; }
    bool isFull() { return (rear + 1) % capacity == front; }
};
```

**模运算的作用**：
- 当索引到达数组末尾时，自动回到开头
- `(rear + 1) % capacity` 实现循环
- 例如：capacity=5，rear=4时，(4+1)%5=0

**答案**：**√（正确）**

---

### 第6题 - 二叉树节点与边的关系（答案：√）

**题目**：一棵有n个节点的二叉树一定有n-1条边。

**分析**：
- **正确！** 这是树的基本性质

**证明**：
- 树是连通无环图
- 每个节点（除了根）都有唯一的父节点
- 每条边连接一个父节点和一个子节点
- n个节点中，除了根节点，其余n-1个节点都有一条入边
- 因此共有**n-1条边**

**通用公式**（任何树）：
```
边数 = 节点数 - 1
E = V - 1
```

**扩展到森林**：
- k棵树组成的森林
- 节点总数n，边数 = n - k

**答案**：**√（正确）**

---

### 第7题 - 中序遍历实现（答案：√）

**题目**：以下代码实现了二叉树的中序遍历，结果是4 2 5 1 3 6。

**树结构**：
```
     1
    / \
   2   3
  / \   \
 4   5   6
```

**代码分析**：
```cpp
void inorderIterative(TreeNode* root) {
    stack<TreeNode*> st;
    TreeNode* curr = root;

    while (curr || !st.empty()) {
        while (curr) {
            st.push(curr);      // 一路向左
            curr = curr->left;
        }
        curr = st.top(); st.pop();  // 回溯
        cout << curr->val << " ";   // 访问
        curr = curr->right;         // 转向右子树
    }
}
```

**执行过程**：
```
1. curr=1，入栈[1]，curr=2
2. curr=2，入栈[1,2]，curr=4
3. curr=4，入栈[1,2,4]，curr=NULL
4. 出栈4，访问4，curr=NULL
5. 出栈2，访问2，curr=5
6. curr=5，入栈[1,5]，curr=NULL
7. 出栈5，访问5，curr=NULL
8. 出栈1，访问1，curr=3
9. curr=3，入栈[3]，curr=NULL
10. 出栈3，访问3，curr=6
11. curr=6，入栈[6]，curr=NULL
12. 出栈6，访问6，curr=NULL

结果：4 2 5 1 3 6 ✓
```

**中序遍历的特点**：
- 左-根-右
- BST的中序遍历是有序的

**答案**：**√（正确）**

---

### 第8题 - BST查找时间复杂度（答案：√）

**题目**：BST查找操作时间复杂度是O(h)，其中h为树高。

**分析**：
- **正确！** 这是BST的基本性质

**查找过程**：
```cpp
TreeNode* searchBST(TreeNode* root, int val) {
    while (root && root->val != val) {
        root = (val < root->val) ? root->left : root->right;
    }
    return root;
}
```

**最坏情况**：
- 从根节点走到叶子节点
- 路径长度 = 树的高度h
- 时间复杂度：**O(h)**

**不同情况下的h**：
| 树的形态 | 高度h | 查找复杂度 |
|---------|-------|----------|
| 完全平衡 | log₂n | O(log n) |
| 随机插入 | 约1.4log₂n | O(log n) |
| 退化成链 | n | O(n) |

**为什么需要平衡树？**
- AVL树、红黑树保证 h=O(log n)
- 使得查找、插入、删除都是O(log n)

**答案**：**√（正确）**

---

### 第9题 - 斐波那契数列DP时间复杂度（答案：×）

**题目**：动态规划版本的斐波那契数列时间复杂度是O(2^n)。

**分析**：
- **错误！** 应该是 **O(n)**

**代码分析**：
```cpp
int fib_dp(int n) {
    if (n <= 1) return n;
    vector<int> dp(n+1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {  // 循环n次
        dp[i] = dp[i-1] + dp[i-2];  // O(1)操作
    }
    return dp[n];
}
```

**时间复杂度分析**：
- 循环执行n次
- 每次循环做O(1)操作
- **总时间：O(n)**

**对比不同实现**：
```cpp
// 1. 递归（O(2^n)）
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 大量重复计算
}

// 2. 动态规划（O(n)）
int fib_dp(int n) {
    // 如上代码
}

// 3. 空间优化的DP（O(n)时间，O(1)空间）
int fib_optimized(int n) {
    if (n <= 1) return n;
    int prev2 = 0, prev1 = 1;
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

**DP的优势**：
- 避免重复计算
- 用空间换时间
- 从指数级优化到线性

**答案**：**×（错误）**

---

### 第10题 - 香蕉问题（打家劫舍）（答案：√）

**题目**：给定的代码能正确找到小猴子吃到最甜的香蕉组合（不能吃相邻的）。

**分析**：
- **正确！** 这是经典的"打家劫舍"问题

**DP状态定义**：
- `dp[i]`：前i个香蕉中能获得的最大甜度

**状态转移**：
```cpp
dp[i] = max(
    dp[i-1],              // 不吃第i个
    bananas[i] + dp[i-2]  // 吃第i个（不能吃i-1）
);
```

**代码验证**：
```cpp
vector<int> bananas = {1, 2, 3, 1};

dp[0] = 1
dp[1] = max(1, 2) = 2
dp[2] = max(2, 3+1) = 4  // 吃香蕉0和2
dp[3] = max(4, 1+2) = 4  // 不吃香蕉3

最大甜度：4
```

**回溯找选择的香蕉**：
```cpp
void findSelectedBananas(vector<int>& bananas, vector<int>& dp) {
    int i = bananas.size() - 1;
    while (i >= 0) {
        if (i == 0) {
            selected.push_back(0);  // 只剩第0个
            break;
        }
        if (dp[i] == dp[i-1]) {
            i--;  // 没吃第i个，继续看i-1
        } else {
            selected.push_back(i);  // 吃了第i个
            i -= 2;  // 跳过i-1
        }
    }
}
```

**对于 {1, 2, 3, 1}**：
- i=3: dp[3]=4 ≠ dp[2]=4，但是 4 != 1+dp[1]=1+2=3
  - 实际上dp[3]=dp[2]，所以i=2
- i=2: dp[2]=4 ≠ dp[1]=2，吃了2，i=0
- i=0: 吃了0

**选择**：香蕉0和2（甜度1+3=4）

**答案**：**√（正确）**

---

## 三、编程题详解（每题25分，共50分）

### 编程题1：划分字符串

#### 题目理解

**输入**：
- n：字符串长度
- s：小写字母字符串
- a[1..n]：长度为i的子串的价值

**任务**：
- 将字符串划分为若干子串
- 每个子串中字母不重复
- 最大化子串价值之和

**示例1**：
```
输入：
6
street
2 1 7 4 3 3

分析：
"street" 可以划分为：
- "str" (长度3，价值7) + "e" (长度1，价值2) + "e" (长度1，价值2) + "t" (长度1，价值2)
  = 7 + 2 + 2 + 2 = 13

- "s" (2) + "tre" (7) + "e" (2) + "t" (2) = 2 + 7 + 2 + 2 = 13

答案：13
```

#### 算法思路

**动态规划**：
- 状态定义：`f[i]` = 以位置i结尾的最大价值
- 状态转移：枚举以i结尾的子串起点j
  ```
  f[i] = max(f[j-1] + a[i-j+1])
  ```
  其中子串s[j..i]不含重复字符

**如何判断重复**：
- 使用**位掩码（bitmask）**
- 26个字母对应26位
- `mask |= (1 << (s[j] - 'a'))`
- 如果 `mask & (1 << c)` 为真，说明字符c已存在

#### 代码详解

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

const int N = 1e5 + 5;
int n;
char s[N];      // 字符串（从1开始）
int a[N];       // 价值数组（从1开始）
long long f[N]; // DP数组

int main() {
    scanf("%d", &n);
    scanf("%s", s + 1);  // 从索引1开始存储
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);

    // DP主循环
    for (int i = 1; i <= n; i++) {
        int mask = 0;  // 字符集合位掩码

        // 枚举子串起点j（从i向左扩展）
        for (int j = i; j >= 1; j--) {
            int cur = 1 << (s[j] - 'a');  // 当前字符的位

            if (mask & cur) break;  // 字符重复，停止扩展

            mask |= cur;  // 添加字符到集合

            // 更新DP值
            // f[i]：以i结尾的最大价值
            // f[j-1]：j之前的最大价值
            // a[i-j+1]：子串s[j..i]的价值
            f[i] = max(f[i], f[j - 1] + a[i - j + 1]);
        }
    }

    printf("%lld\n", f[n]);
    return 0;
}
```

#### 算法复杂度

**时间复杂度**：
- 外层循环：O(n)
- 内层循环：最多26次（字母种类）
- **总计**：O(26n) = **O(n)**

**空间复杂度**：O(n)

#### 位掩码技巧

**为什么用位掩码？**
1. **空间效率**：26个字母用26位，一个int足够
2. **时间效率**：位运算快
3. **简洁性**：一行代码判断重复

**位运算操作**：
```cpp
// 设置第i位为1
mask |= (1 << i);

// 检查第i位是否为1
if (mask & (1 << i))

// 清除第i位
mask &= ~(1 << i);

// 切换第i位
mask ^= (1 << i);
```

**示例**：
```
字母 'a' → 第0位
字母 'b' → 第1位
字母 'c' → 第2位
...

"abc" → mask = 0b111 = 7
"ab"  → mask = 0b11 = 3
```

---

### 编程题2：货物运输

#### 题目理解

**输入**：
- n：城市数量（编号1到n，1是首都）
- n-1条边：构成一棵树

**任务**：
- 从首都出发，访问所有城市
- 可以重复经过城市和道路
- 最小化总路径长度

**关键观察**：
- 这是一棵树，不是一般图
- 需要遍历所有节点
- 可以重复访问

#### 算法思路

**核心思想**：
1. 每条边至少要走2次（去+回）
2. 但有一条路径可以不回来（最后停留）
3. 最优策略：**走完所有边的2倍，减去最长路径**

**公式**：
```
答案 = 2 × 所有边权和 - 最长路径
```

**为什么？**
- 普通DFS遍历：每条边走2次（下去+回来）
- 优化：最后一条路径不需要返回
- 选择最长的路径作为"不返回"的路径

**图示**：
```
示例1：
     1
    /|\
   6 1 5
  2  3  4

所有边权和：6+1+5=12
DFS遍历需要：12×2=24

优化：最后停在最远的叶子（通过边权6）
答案：24-6=18

路径：1→2(6)→1→3(1)→1→4(5) = 6+6+1+1+5 = 19 ✗
更优：1→3(1)→1→4(5)→1→2(6) = 1+1+5+5+6 = 18 ✓
```

#### 代码详解

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

const int N = 1e5 + 5;
int n;
vector<vector<pair<int, int>>> e;  // 邻接表：e[u] = {(v, w), ...}
long long s;   // 所有边权和
long long mx;  // 从根到叶子的最长距离

// DFS求从根节点到所有叶子的最长距离
void dfs(int u, int f, long long d) {
    mx = max(d, mx);  // 更新最长距离

    for (auto p : e[u]) {
        int v = p.first;
        int w = p.second;

        if (v != f) {  // 避免回到父节点
            dfs(v, u, d + w);  // 递归访问子节点
        }
    }
}

int main() {
    scanf("%d", &n);
    e.resize(n + 1);

    // 读取边
    for (int i = 1; i < n; i++) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);

        // 无向边，双向添加
        e[u].emplace_back(make_pair(v, w));
        e[v].emplace_back(make_pair(u, w));

        s += w;  // 累加边权
    }

    // 从节点1（首都）开始DFS
    dfs(1, 0, 0);

    // 答案：2倍边权和 - 最长路径
    printf("%lld\n", s * 2 - mx);
    return 0;
}
```

#### 算法正确性证明

**引理**：树的欧拉回路
- 欧拉回路：遍历所有边恰好一次
- 树的欧拉回路：每条边走2次
- 长度：2 × 边权和

**优化**：
- 不需要回到起点
- 选择离起点最远的点作为终点
- 减去这条最长路径

**为什么是最长路径？**
- 假设最优路径结束在点v
- 从根到v的路径长度为d(1,v)
- 总长度：2S - d(1,v)
- 要最小化总长度，应最大化d(1,v)
- 因此选择最远的点

#### 复杂度分析

**时间复杂度**：
- 读入：O(n)
- DFS：O(n)
- **总计**：O(n)

**空间复杂度**：O(n)（邻接表）

#### 示例验证

**示例1**：
```
4
1 2 6
1 3 1
3 4 5

树结构：
     1
    /|\
   6 1
  2  3
      |
      5
      4

s = 6 + 1 + 5 = 12
从1出发的最长路径：1→3→4，长度 1+5=6
答案：12×2 - 6 = 18 ✓
```

**示例2**：
```
7
1 2 1
2 3 1
3 4 1
7 6 1
6 5 1
5 1 1

树结构：
  1---5---6---7
  |
  2---3---4

s = 6
最长路径：1→5→6→7 或 1→2→3→4，长度都是3
答案：6×2 - 3 = 9 ✓
```

---

## 总结

### 知识点分布

| 知识点 | 题号 | 难度 |
|--------|------|------|
| **面向对象** | 1,2,3 | 中 |
| **数据结构-栈队列** | 4,5,判4,判5 | 易 |
| **二叉树** | 6,7,8,判3,判6,判7 | 中 |
| **图算法** | 11,编程2 | 中 |
| **贪心算法** | 9 | 难 |
| **动态规划** | 10,15,判9,判10,编程1 | 难 |
| **二叉搜索树** | 13,14,判8 | 中 |
| **时间复杂度** | 12 | 易 |
| **虚函数与多态** | 1,判1 | 中 |

### 学习建议

1. **面向对象**：
   - 掌握虚函数与多态
   - 理解虚析构函数的必要性
   - 练习继承和重写

2. **数据结构**：
   - 熟练使用STL容器
   - 理解栈、队列、树的实现
   - 掌握树的遍历算法

3. **算法**：
   - DP：状态定义、转移方程
   - 贪心：哈夫曼编码
   - 图：DFS、BFS、树的性质

4. **编程技巧**：
   - 位运算优化
   - 空间换时间
   - 递归与迭代的转换

### 难点突破

**最难的题**：
1. **第9题（哈夫曼编码）**：需要理解贪心构造过程
2. **编程题1**：DP + 位运算的综合应用
3. **第10题（格雷码）**：需要理解递归生成规律

**易错点**：
1. 虚析构函数的理解
2. STL容器操作的细节
3. 树的高度定义
4. 时间复杂度分析

---

## 附录：参考资源

### 在线练习平台
- LeetCode
- 洛谷
- Codeforces

### 推荐书籍
- 《C++ Primer》
- 《算法导论》
- 《数据结构与算法分析》

### 相关算法
- 树的遍历：DFS、BFS
- 动态规划：背包、打家劫舍
- 贪心算法：哈夫曼编码
- 位运算技巧

---

**祝各位考生取得好成绩！** 🎉
