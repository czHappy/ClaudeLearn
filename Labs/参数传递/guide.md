# 实验指导书 - 参数传递

## 实验信息
- **实验名称**: 数据交换中心
- **知识点**: 值传递、引用传递、指针传递、数组参数传递
- **难度等级**: ⭐⭐⭐
- **预计时长**: 90分钟

## 实验目标

通过实现一个数据交换中心系统，深入理解C++中不同的参数传递方式，掌握它们的使用场景和性能特点。

### 学习目标
1. 理解值传递的工作原理和局限性
2. 掌握引用传递的语法和应用场景
3. 理解指针传递的机制和用法
4. 了解数组作为参数的特殊性
5. 能够根据需求选择合适的参数传递方式
6. 理解大对象传递的性能考虑

## 知识点讲解

### 1. 值传递（Pass by Value）

值传递是C++默认的参数传递方式，函数接收的是实参的副本。

```cpp
void increment(int x) {
    x++;  // 只修改副本，不影响原变量
}

int main() {
    int num = 5;
    increment(num);
    // num 仍然是 5
}
```

**特点**:
- 函数内部操作的是参数的副本
- 不会影响原始数据
- 对于大对象，拷贝开销较大

### 2. 引用传递（Pass by Reference）

引用传递使用引用符号 `&`，函数直接操作原始数据。

```cpp
void increment(int& x) {
    x++;  // 直接修改原变量
}

int main() {
    int num = 5;
    increment(num);
    // num 变成 6
}
```

**特点**:
- 不产生副本，效率高
- 可以修改原始数据
- 语法简洁，使用安全
- 必须用已存在的变量初始化

### 3. 指针传递（Pass by Pointer）

指针传递传递的是地址，通过解引用操作原始数据。

```cpp
void increment(int* x) {
    (*x)++;  // 通过指针修改原变量
}

int main() {
    int num = 5;
    increment(&num);
    // num 变成 6
}
```

**特点**:
- 传递地址，开销小
- 可以修改原始数据
- 可以传递 nullptr
- 需要手动解引用

### 4. 数组参数传递

数组名本质上是指针，传递数组时实际传递的是首地址。

```cpp
// 以下三种声明等价
void processArray(int arr[], int size);
void processArray(int* arr, int size);
void processArray(int arr[10], int size);  // 10会被忽略

int main() {
    int data[5] = {1, 2, 3, 4, 5};
    processArray(data, 5);
    // data 可能被修改
}
```

**注意**:
- 数组大小信息会丢失，需要额外传递
- 可以修改数组元素
- 不会发生数组整体拷贝

### 5. 常量引用（const Reference）

用于只读访问大对象，避免拷贝开销。

```cpp
struct LargeObject {
    int data[1000];
};

void process(const LargeObject& obj) {
    // 可以读取 obj，但不能修改
    // obj.data[0] = 1;  // 编译错误
}
```

### 6. 参数传递方式对比

| 传递方式 | 语法 | 可修改原数据 | 拷贝开销 | 可传nullptr | 使用场景 |
|---------|------|-------------|---------|-------------|----------|
| 值传递 | `int x` | 否 | 有 | 否 | 小对象，不需修改 |
| 引用传递 | `int& x` | 是 | 无 | 否 | 需要修改，或大对象只读（const&） |
| 指针传递 | `int* x` | 是 | 无 | 是 | 需要表示"可选"，或C风格代码 |
| 常量引用 | `const int& x` | 否 | 无 | 否 | 大对象只读访问 |

## 实验任务

### 任务1: 值传递演示

实现一个函数，尝试通过值传递修改变量，观察结果。

**要求**:
- 实现 `tryModifyByValue` 函数
- 参数使用值传递
- 函数内部尝试修改参数
- 观察调用前后变量的变化

### 任务2: 引用传递 - swap函数

实现使用引用传递的交换函数。

**要求**:
- 实现 `swapByReference` 函数
- 使用引用参数 `int& a, int& b`
- 交换两个变量的值

### 任务3: 指针传递 - swap函数

实现使用指针传递的交换函数。

**要求**:
- 实现 `swapByPointer` 函数
- 使用指针参数 `int* a, int* b`
- 交换两个变量的值
- 正确处理空指针情况

### 任务4: 数组参数传递

实现数组相关的处理函数。

**要求**:
- 实现 `arraySum` 函数 - 计算数组总和
- 实现 `arrayReverse` 函数 - 反转数组
- 实现 `arraySort` 函数 - 数组排序（升序）
- 注意数组大小需要作为参数传递

### 任务5: 综合对比 - 三种方式实现增量

实现同一功能的三个版本，对比不同参数传递方式。

**要求**:
- 实现 `incrementByValue` - 值传递版本
- 实现 `incrementByReference` - 引用传递版本
- 实现 `incrementByPointer` - 指针传递版本
- 观察哪些版本能成功修改原变量

### 任务6: 大对象传递策略

定义并处理大型数据结构，选择合适的传递方式。

**要求**:
- 定义 `DataBlock` 结构体（包含大数组）
- 实现 `processDataByValue` - 值传递版本
- 实现 `processDataByReference` - 引用传递版本
- 实现 `processDataByConstReference` - 常量引用版本
- 比较性能差异（通过观察拷贝次数）

### 任务7: 引用与指针的选择

实现一个查找函数，体会引用与指针的使用场景。

**要求**:
- 实现 `findMax` - 使用引用返回最大值的引用
- 实现 `findElement` - 使用指针返回找到的元素（找不到返回nullptr）
- 理解什么时候用引用，什么时候用指针

## 实验步骤

### 第一步: 环境准备
1. 打开 `submit.cpp` 文件
2. 阅读代码框架和TODO标记
3. 理解每个函数的要求

### 第二步: 实现基础函数
1. 完成任务1的值传递演示
2. 完成任务2的引用swap
3. 完成任务3的指针swap
4. 编译运行，验证swap功能

### 第三步: 实现数组处理
1. 完成任务4的三个数组函数
2. 注意数组边界检查
3. 测试各种数组大小

### 第四步: 综合对比
1. 完成任务5的三种增量实现
2. 观察输出，理解差异
3. 完成任务6的大对象处理
4. 思考性能影响

### 第五步: 高级应用
1. 完成任务7的查找函数
2. 理解引用和指针的使用场景
3. 运行完整程序，检查所有输出

### 第六步: 总结反思
1. 对比三种参数传递方式
2. 总结使用场景
3. 思考性能优化策略

## 测试用例

程序运行后应输出类似以下内容:

```
=== 数据交换中心系统 ===

--- 任务1: 值传递演示 ---
修改前: 10
函数内部: 11
修改后: 10 (未改变)

--- 任务2: 引用传递 swap ---
交换前: a=3, b=7
交换后: a=7, b=3

--- 任务3: 指针传递 swap ---
交换前: a=15, b=25
交换后: a=25, b=15

--- 任务4: 数组参数传递 ---
原始数组: 5 2 8 1 9
数组总和: 25
反转后: 9 1 8 2 5
排序后: 1 2 5 8 9

--- 任务5: 三种方式对比 ---
值传递: 原值=100, 处理后=100
引用传递: 原值=100, 处理后=101
指针传递: 原值=100, 处理后=101

--- 任务6: 大对象传递 ---
值传递: 拷贝构造函数被调用
引用传递: 无拷贝
常量引用: 无拷贝，只读访问

--- 任务7: 引用与指针选择 ---
数组最大值: 9
查找5: 找到
查找100: 未找到
```

## 常见问题

### Q1: 引用和指针有什么区别？

**区别**:
- 引用必须初始化，指针可以为nullptr
- 引用一旦绑定不能改变，指针可以重新指向
- 引用使用更安全，指针更灵活
- 引用语法简洁，指针需要解引用

**选择建议**:
- 需要表示"可选"时用指针
- 确定有值且不需改变绑定时用引用
- C++风格优先用引用，C风格用指针

### Q2: 为什么数组参数会丢失大小信息？

数组名在传递时会退化为指针，指针本身不包含数组大小信息。因此需要：
- 额外传递数组大小参数
- 或使用C++容器（如vector）
- 或使用数组引用（如 `int (&arr)[10]`）

### Q3: 什么时候使用const引用？

使用场景:
- 传递大对象但不需要修改
- 避免拷贝开销
- 既保证效率又保证安全

```cpp
void print(const vector<int>& vec) {
    // 高效且安全
}
```

### Q4: 值传递一定效率低吗？

不一定:
- 小对象（int, char等）值传递很快
- 编译器可能优化拷贝（RVO）
- 值传递语义更清晰（不会修改）

选择原则:
- 基本类型和小对象：值传递
- 大对象只读：const引用
- 需要修改：引用或指针

### Q5: 如何判断是否应该使用指针而非引用？

使用指针的情况:
- 需要传递nullptr表示"无值"
- 需要重新绑定到不同对象
- 需要指针算术
- 与C库交互

使用引用的情况:
- 确定有值
- 不需要重新绑定
- 追求语法简洁

## 扩展挑战

### 挑战1: 实现通用swap模板
使用模板实现适用于任意类型的swap函数。

### 挑战2: 性能测试
编写代码测量大对象的值传递、引用传递、指针传递的时间差异。

### 挑战3: 智能指针
了解 `std::unique_ptr` 和 `std::shared_ptr` 的参数传递最佳实践。

### 挑战4: 完美转发
研究 `std::forward` 和右值引用在参数传递中的应用。

## 评分标准

| 评分项 | 分值 | 要求 |
|--------|------|------|
| 值传递演示 | 10分 | 正确实现并理解无法修改原变量 |
| 引用swap | 15分 | 正确实现引用交换 |
| 指针swap | 15分 | 正确实现指针交换，处理空指针 |
| 数组处理 | 20分 | 三个数组函数都正确 |
| 三种方式对比 | 15分 | 正确实现三种增量函数 |
| 大对象处理 | 15分 | 正确实现并理解性能差异 |
| 代码规范 | 10分 | 命名、格式、注释规范 |

**总分**: 100分
**及格线**: 60分

## 学习资源

### 推荐阅读
- C++ Primer (第5版) - 第6章 函数
- Effective C++ - 条款20: 宁以pass-by-reference-to-const替换pass-by-value
- C++ Core Guidelines - F.16-F.18 参数传递部分

### 在线资源
- cppreference.com - Function declarations
- isocpp.org - C++ FAQ about references

## 总结

通过本实验，你应该掌握:
1. 三种参数传递方式的区别和使用场景
2. 数组参数的特殊性
3. 如何选择合适的参数传递方式
4. 性能和安全性的权衡

记住:
- **小对象不修改** → 值传递
- **大对象只读** → const引用
- **需要修改** → 引用（确定有值）或指针（可能为空）
- **数组** → 指针+大小，或使用容器

祝实验顺利！
