# C++ 编程题：棋盘格子定位

## 题目信息
- **难度**：中等
- **考察点**：循环、除法运算、取余运算、数学推理
- **适用对象**：学习了循环基础的学生
- **预计完成时间**：30-40 分钟

---

## 第一部分：学习材料（10分钟阅读）

### 1. 整数除法和取余运算

在 C++ 中，两个整数相除会得到整数结果（向下取整）：

```cpp
int a = 7 / 3;   // a = 2 (不是 2.333...)
int b = 10 / 5;  // b = 2
int c = 5 / 10;  // c = 0 (小于1的都是0)
```

取余运算符 `%` 返回除法的余数：

```cpp
int a = 7 % 3;   // a = 1 (7除以3余1)
int b = 10 % 5;  // b = 0 (10除以5余0)
int c = 8 % 3;   // c = 2 (8除以3余2)
```

**重要性质**：
```cpp
任意数 k = (k / m) * m + (k % m)
例如：7 = (7/3) * 3 + (7%3) = 2*3 + 1 = 7 ✓
```

### 2. 二维数组和坐标

在棋盘或网格中，我们用 **(行号, 列号)** 来表示位置：

```
  列: 1   2   3   4
行
1    [ ] [ ] [ ] [ ]
2    [ ] [ ] [ ] [ ]
3    [ ] [ ] [ ] [ ]
```

- 第 1 行第 1 列：位置 (1, 1)
- 第 2 行第 3 列：位置 (2, 3)

### 3. 输入输出格式

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m, k;
    cin >> n >> m >> k;  // 一次读入三个整数

    int row = 计算行号;
    int col = 计算列号;

    cout << row << " " << col << endl;  // 输出时用空格分隔

    return 0;
}
```

---

## 第二部分：问题描述

### 背景

有一个 **n 行 m 列** 的棋盘格子，我们按照以下规则给每个格子编号：

**填充规则**：
1. 从第 1 行开始，从左往右依次填入 1, 2, 3, ..., m
2. 第 2 行继续从左往右填入 m+1, m+2, ..., 2m
3. 第 3 行继续从左往右填入 2m+1, 2m+2, ..., 3m
4. 以此类推，直到填满整个棋盘

### 示例

一个 **3 行 4 列** (n=3, m=4) 的棋盘：

```
第1行：  1   2   3   4
第2行：  5   6   7   8
第3行：  9  10  11  12
```

一个 **4 行 5 列** (n=4, m=5) 的棋盘：

```
第1行：  1   2   3   4   5
第2行：  6   7   8   9  10
第3行： 11  12  13  14  15
第4行： 16  17  18  19  20
```

### 你的任务

给定棋盘大小 **n×m** 和一个数字 **k**，请输出数字 k 所在的**行号**和**列号**。

**注意**：行号和列号都从 1 开始计数（不是从 0 开始）。

---

## 第三部分：输入输出格式

### 输入格式
一行三个整数：`n m k`
- n：棋盘行数 (1 ≤ n ≤ 1000)
- m：棋盘列数 (1 ≤ m ≤ 1000)
- k：要查找的数字 (1 ≤ k ≤ n×m)

### 输出格式
一行两个整数：`row col`（用空格分隔）
- row：k 所在的行号
- col：k 所在的列号

---

## 第四部分：示例

### 示例 1

**输入：**
```
3 4 7
```

**输出：**
```
2 3
```

**解释：**
- 3行4列的棋盘
- 数字7在第2行第3列：
  ```
  1   2   3   4
  5   6  [7]  8
  9  10  11  12
  ```

### 示例 2

**输入：**
```
4 5 1
```

**输出：**
```
1 1
```

**解释：**
- 数字1在第1行第1列（左上角）

### 示例 3

**输入：**
```
4 5 20
```

**输出：**
```
4 5
```

**解释：**
- 4行5列的棋盘，数字20在第4行第5列（右下角）
  ```
   1   2   3   4   5
   6   7   8   9  10
  11  12  13  14  15
  16  17  18  19 [20]
  ```

### 示例 4

**输入：**
```
5 3 8
```

**输出：**
```
3 2
```

**解释：**
- 5行3列的棋盘，数字8在第3行第2列：
  ```
  1  2  3
  4  5  6
  7 [8] 9
  10 11 12
  13 14 15
  ```

---

## 第五部分：解题提示（卡住时再看）

<details>
<summary>点击查看提示 1：观察规律</summary>

观察以下规律：
- 第1行的数字：1, 2, 3, ..., m （共 m 个数字）
- 第2行的数字：m+1, m+2, ..., 2m （共 m 个数字）
- 第3行的数字：2m+1, 2m+2, ..., 3m （共 m 个数字）

**关键问题**：
- 如果数字 k 在第 r 行，那么在 k 之前有多少个完整的行？
- 这些完整的行一共有多少个数字？

</details>

<details>
<summary>点击查看提示 2：数学公式</summary>

假设 k 在第 r 行第 c 列：
- 在 k 之前有 (r-1) 个完整的行
- 这些完整的行共有 (r-1) × m 个数字
- 加上当前行的 c 个数字，正好等于 k

所以：**k = (r-1) × m + c**

现在的问题是：已知 k 和 m，如何求 r 和 c？

思考：
- 如果 k = 7, m = 4，那么 7 = (r-1) × 4 + c
- 可以通过除法和取余运算来求解

</details>

<details>
<summary>点击查看提示 3：公式推导</summary>

从 `k = (r-1) × m + c` 可以推导出：

**行号 r**：
```
k-1 = (r-1) × m + (c-1)
(k-1) / m = r-1 （向下取整）
r = (k-1) / m + 1
```

**列号 c**：
```
(k-1) % m = c-1
c = (k-1) % m + 1
```

**为什么要用 k-1？**
- 因为如果 k 正好是某行的最后一个数（如 k=8, m=4），直接用 k/m 会多算一行

验证：k=7, m=4
- r = (7-1)/4 + 1 = 6/4 + 1 = 1 + 1 = 2 ✓
- c = (7-1)%4 + 1 = 6%4 + 1 = 2 + 1 = 3 ✓

</details>

<details>
<summary>点击查看提示 4：代码框架</summary>

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m, k;
    cin >> n >> m >> k;

    // 计算行号（使用除法）
    int row = (k - 1) / m + 1;

    // 计算列号（使用取余）
    int col = (k - 1) % m + 1;

    cout << row << " " << col << endl;

    return 0;
}
```

</details>

---

## 第六部分：思考题（选做）

完成基础题目后，思考以下问题：

### 思考题 1：反向查询
如果给定行号 r 和列号 c，你能计算出该位置的数字是多少吗？

### 思考题 2：Z字形填充
如果填充规则改为：
- 第1行：从左往右填 1, 2, 3, 4
- 第2行：从右往左填 5, 6, 7, 8
- 第3行：从左往右填 9, 10, 11, 12
- 第4行：从右往左填 13, 14, 15, 16

即奇数行从左往右，偶数行从右往左（Z字形），这时如何求 k 的位置？

### 思考题 3：螺旋填充
如果按螺旋形填充（从外向内），该如何求解？

```
1  2  3  4
12 13 14 5
11 16 15 6
10  9  8  7
```

---

## 提交要求

1. 将代码保存为 `chess_position.cpp`
2. 确保能通过所有示例测试
3. 测试边界情况：k=1（第一个格子）和 k=n×m（最后一个格子）
4. 代码中添加注释说明你的思路

---

## 评分标准

| 项目 | 分数 | 说明 |
|------|------|------|
| 程序能编译运行 | 20分 | 无语法错误 |
| 示例1测试通过 | 15分 | 3 4 7 → 2 3 |
| 示例2测试通过 | 15分 | 4 5 1 → 1 1 |
| 示例3测试通过 | 15分 | 4 5 20 → 4 5 |
| 示例4测试通过 | 15分 | 5 3 8 → 3 2 |
| 边界情况处理 | 10分 | k=1 和 k=n×m |
| 代码可读性 | 10分 | 有注释，变量命名清晰 |
| **总分** | **100分** | |
| 思考题1（反向查询） | +10分 | 加分项 |
| 思考题2（Z字形） | +15分 | 加分项 |

**及格线**：60 分

---

## 调试建议

如果你的答案不对，可以这样调试：

1. **手算验证**：先用纸笔画一个小棋盘（如3×4），标注出每个数字的位置
2. **打印中间值**：
   ```cpp
   cout << "k-1 = " << (k-1) << endl;
   cout << "(k-1)/m = " << (k-1)/m << endl;
   cout << "(k-1)%m = " << (k-1)%m << endl;
   ```
3. **检查特殊情况**：
   - k=1 应该在 (1, 1)
   - k=m 应该在 (1, m)（第一行最后一列）
   - k=m+1 应该在 (2, 1)（第二行第一列）

---

**出题时间**：2025-11-23
**难度等级**：★★★☆☆（3/5）
