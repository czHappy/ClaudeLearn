# 实验3：函数 - 计算器工厂

## 实验目标
通过实现一个功能丰富的数学计算器库，掌握C++函数的各种特性和使用方法。

## 知识点清单
- [x] 函数声明与定义
- [x] 函数原型与头文件
- [x] 返回值类型
- [x] 函数签名
- [x] 函数重载
- [x] 默认参数
- [x] 内联函数

## 实验背景
你是一家软件公司的开发者，需要开发一个数学计算器库。这个库需要提供各种数学计算功能，并且要设计良好的函数接口，便于其他开发者使用。

## 实验任务

### 任务1：函数声明与定义
理解函数声明（原型）和定义的分离：
- 在程序开头声明所有函数原型
- 在 main 函数之后实现函数定义
- 体会声明和定义分离的好处

需要实现的函数：
- `int add(int a, int b)` - 整数加法
- `double add(double a, double b)` - 浮点数加法
- `int factorial(int n)` - 阶乘计算

### 任务2：函数重载（Overloading）
实现一组重载的计算函数，体验函数重载的便利：

**绝对值函数 abs()：**
- `int abs(int x)` - 整数绝对值
- `double abs(double x)` - 浮点数绝对值
- `long long abs(long long x)` - 长整型绝对值

**最大值函数 max()：**
- `int max(int a, int b)` - 两个整数的最大值
- `int max(int a, int b, int c)` - 三个整数的最大值
- `double max(double a, double b)` - 两个浮点数的最大值

**打印函数 print()：**
- `void print(int x)` - 打印整数
- `void print(double x)` - 打印浮点数
- `void print(const char* str)` - 打印字符串

### 任务3：默认参数
实现带有默认参数的函数：

**幂运算 power()：**
- `double power(double base, int exp = 2)` - 默认计算平方

**数值格式化 format()：**
- `void format(double value, int precision = 2, bool showSign = false)`
- 按指定精度格式化输出数值，可选显示正号

**范围生成 printRange()：**
- `void printRange(int start, int end, int step = 1)`
- 打印从start到end的数列，默认步长为1

### 任务4：内联函数
实现适合内联的小型函数：

- `inline int square(int x)` - 计算平方
- `inline int cube(int x)` - 计算立方
- `inline bool isEven(int x)` - 判断偶数
- `inline bool isOdd(int x)` - 判断奇数
- `inline int min(int a, int b)` - 取最小值

### 任务5：递归函数
实现几个经典的递归函数：

- `int fibonacci(int n)` - 斐波那契数列第n项
- `int gcd(int a, int b)` - 最大公约数（欧几里得算法）
- `int sumDigits(int n)` - 各位数字之和
- `void printBinary(int n)` - 递归打印二进制表示

### 任务6：综合应用 - 简易计算器
整合所有函数，实现一个交互式计算器：
- 支持基本运算（加、减、乘、除）
- 支持高级运算（幂、阶乘、最大公约数）
- 支持数值分析（是否偶数、是否质数）

## 输入输出示例

### 示例1：函数重载
```
=== 函数重载演示 ===
abs(-5) = 5
abs(-3.14) = 3.14
abs(-1000000000LL) = 1000000000

max(3, 7) = 7
max(3, 7, 5) = 7
max(3.14, 2.72) = 3.14

print(42)    -> 整数: 42
print(3.14)  -> 浮点数: 3.14
print("Hi")  -> 字符串: Hi
```

### 示例2：默认参数
```
=== 默认参数演示 ===
power(3) = 9        // 默认计算平方
power(2, 10) = 1024 // 指定指数

format(3.14159)           -> 3.14
format(3.14159, 4)        -> 3.1416
format(3.14159, 2, true)  -> +3.14

printRange(1, 5)    -> 1 2 3 4 5
printRange(0, 10, 2) -> 0 2 4 6 8 10
```

### 示例3：递归函数
```
=== 递归函数演示 ===
fibonacci(10) = 55
gcd(48, 18) = 6
sumDigits(12345) = 15
printBinary(13) -> 1101
```

### 示例4：计算器
```
======= 数学计算器 =======
1. 基本运算
2. 幂运算
3. 阶乘
4. 最大公约数
5. 斐波那契数列
0. 退出
==========================
请选择: 1

输入两个数: 10 3
选择运算(+,-,*,/): +
结果: 10 + 3 = 13
```

## 函数签名说明
函数签名包括函数名和参数类型列表（不包括返回类型）：
- `int add(int, int)` 和 `double add(double, double)` 签名不同，可以重载
- `int func(int)` 和 `double func(int)` 签名相同（仅返回类型不同），不能重载

## 评分标准
1. 函数声明与定义分离规范（10分）
2. 函数重载实现正确（20分）
3. 默认参数使用得当（20分）
4. 内联函数合理应用（15分）
5. 递归函数正确实现（20分）
6. 综合计算器功能完整（15分）

## 提示
1. 函数重载通过参数类型或数量区分，不能仅靠返回类型
2. 默认参数从右向左提供，不能跳跃
3. 内联函数适合短小、频繁调用的函数
4. 递归必须有终止条件，否则会栈溢出
5. 使用 `<iomanip>` 控制输出格式

## 思考题
1. 为什么不能仅通过返回类型来重载函数？
2. 内联函数和宏定义相比有什么优势？
3. 递归和循环相比，各有什么优缺点？
4. 函数声明和定义分离有什么实际意义？
