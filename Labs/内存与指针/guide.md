# 实验：内存管理训练营

## 实验背景

欢迎来到**内存管理训练营**！在这个实验中，你将扮演一名系统程序员，设计并实现一个动态数组管理器。通过这个实践项目，你将深入理解指针的本质、内存的分配与释放，以及如何编写安全、高效的内存管理代码。

内存管理是C++编程的核心技能之一。指针作为直接操作内存的工具，既强大又危险——用得好可以写出高效的代码，用不好则会导致程序崩溃、内存泄漏等严重问题。

## 学习目标

完成本实验后，你将能够：

1. 正确定义和初始化指针变量
2. 熟练使用取地址运算符(&)和解引用运算符(*)
3. 理解指针与数组的内在关系
4. 掌握指针的算术运算和比较运算
5. 使用多级指针处理复杂数据结构
6. 正确使用new/delete进行动态内存分配
7. 识别并避免内存泄漏和悬空指针问题
8. 理解const与指针的各种组合方式

---

## 知识点详解

### 1. 指针的定义与初始化

指针是存储内存地址的变量。每个指针都有一个类型，指示它所指向的数据类型。

```cpp
// 指针的定义
int* ptr;           // 定义一个指向int的指针（未初始化，危险！）
int* ptr = nullptr; // 初始化为空指针（推荐）

// 取地址运算符 &
int value = 42;
int* p = &value;    // p存储value的地址

// 解引用运算符 *
int x = *p;         // 通过指针访问value的值，x = 42
*p = 100;           // 通过指针修改value的值
```

**关键概念**：
- `&variable` 获取变量的内存地址
- `*pointer` 访问指针所指向的值
- 未初始化的指针是"野指针"，使用它会导致未定义行为

### 2. 指针与数组的关系

数组名本质上是指向数组首元素的常量指针。

```cpp
int arr[5] = {10, 20, 30, 40, 50};

// 数组名就是首元素地址
int* p = arr;       // 等价于 int* p = &arr[0];

// 两种访问方式等价
arr[2];             // 下标访问，值为30
*(arr + 2);         // 指针算术访问，值为30
p[2];               // 指针也可以使用下标
*(p + 2);           // 指针算术

// 遍历数组的指针方式
for (int* ptr = arr; ptr < arr + 5; ptr++) {
    cout << *ptr << " ";
}
```

### 3. 指针运算

指针支持特定的算术运算和比较运算。

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;

// 算术运算（单位是元素大小，不是字节）
p++;        // 移动到下一个int（地址增加sizeof(int)）
p--;        // 移动到上一个int
p + 3;      // 指向arr[3]
p - 1;      // 指向arr[0]

// 指针相减（得到元素个数差）
int* start = arr;
int* end = arr + 5;
ptrdiff_t count = end - start;  // count = 5

// 比较运算
if (p < end) { /* p在end之前 */ }
if (p == nullptr) { /* p是空指针 */ }
if (p != start) { /* p不指向起始位置 */ }
```

### 4. 多级指针

指针的指针，用于间接访问或修改指针变量。

```cpp
int value = 100;
int* p = &value;      // p指向value
int** pp = &p;        // pp指向p

// 访问方式
*pp;     // 得到p的值（即value的地址）
**pp;    // 得到value的值（100）

// 修改
**pp = 200;           // value变为200

// 实际应用：函数中修改指针参数
void allocate(int** ptr) {
    *ptr = new int(42);
}

int* myPtr = nullptr;
allocate(&myPtr);     // myPtr现在指向新分配的内存
```

### 5. 动态内存分配

使用new/delete在堆上分配和释放内存。

```cpp
// 单个变量
int* p = new int;       // 分配未初始化的int
int* q = new int(42);   // 分配并初始化为42
int* r = new int{42};   // C++11列表初始化

delete p;               // 释放内存
delete q;
delete r;

// 数组
int* arr = new int[10];         // 分配10个int的数组
int* arr2 = new int[5]{1,2,3};  // 分配并初始化

delete[] arr;           // 释放数组（必须用delete[]）
delete[] arr2;

// 重要原则
// new    配对 delete
// new[]  配对 delete[]
// 不能混用！
```

### 6. const与指针

const和指针有三种组合方式：

```cpp
int value = 10;
int other = 20;

// 1. 指向常量的指针（底层const）
// 不能通过指针修改所指向的值，但指针本身可以改变指向
const int* p1 = &value;
// *p1 = 20;    // 错误！不能修改值
p1 = &other;    // 正确，可以改变指向

// 2. 常量指针（顶层const）
// 指针本身不能改变指向，但可以修改所指向的值
int* const p2 = &value;
*p2 = 20;       // 正确，可以修改值
// p2 = &other; // 错误！不能改变指向

// 3. 指向常量的常量指针
// 既不能修改值，也不能改变指向
const int* const p3 = &value;
// *p3 = 20;    // 错误！
// p3 = &other; // 错误！

// 记忆技巧：const在*左边，修饰指向的内容；const在*右边，修饰指针本身
```

### 7. 内存安全问题

#### 内存泄漏
分配的内存没有被释放：
```cpp
void memoryLeak() {
    int* p = new int[100];
    // 函数结束，p被销毁，但内存未释放！
    // 这100个int的内存泄漏了
}

// 正确做法
void noLeak() {
    int* p = new int[100];
    // 使用p...
    delete[] p;  // 使用完毕后释放
}
```

#### 悬空指针
指针指向已释放的内存：
```cpp
int* p = new int(42);
delete p;
// 现在p是悬空指针！
// *p = 10;  // 未定义行为！

// 正确做法
delete p;
p = nullptr;  // 释放后置空
```

#### 重复释放
```cpp
int* p = new int(42);
delete p;
// delete p;  // 错误！重复释放

// 使用nullptr可以安全地多次delete
p = nullptr;
delete p;    // 安全，delete nullptr什么都不做
```

---

## 实验任务

### 任务1：指针基础操作（15分）

实现 `pointerBasics()` 函数：
- 定义整型变量并初始化
- 定义指针指向该变量
- 通过指针读取和修改变量值
- 输出变量地址和值

**预期输出格式**：
```
=== 任务1: 指针基础操作 ===
变量value的值: 42
变量value的地址: 0x...
指针ptr的值(地址): 0x...
指针ptr指向的值: 42
通过指针修改后，value的值: 100
```

### 任务2：指针与数组遍历（15分）

实现 `pointerArrayTraversal()` 函数：
- 创建一个包含5个元素的整型数组
- 使用指针方式遍历数组
- 计算数组元素之和
- 找出最大值及其索引位置

**预期输出格式**：
```
=== 任务2: 指针与数组遍历 ===
数组元素: 10 20 30 40 50
使用指针遍历:
  元素[0] = 10, 地址 = 0x...
  元素[1] = 20, 地址 = 0x...
  ...
数组元素之和: 150
最大值: 50, 位置: 4
```

### 任务3：指针算术运算（15分）

实现 `pointerArithmetic()` 函数：
- 演示指针的加减运算
- 演示指针间的减法（计算距离）
- 使用指针比较遍历数组

**预期输出格式**：
```
=== 任务3: 指针算术运算 ===
数组首地址: 0x...
ptr + 2 指向的值: 30
指针移动演示:
  ptr++后指向: 20
  ptr+=2后指向: 40
end - start = 5 个元素
使用指针比较遍历: 10 20 30 40 50
```

### 任务4：多级指针操作（10分）

实现 `multiLevelPointer()` 函数：
- 创建变量、一级指针、二级指针
- 演示通过各级指针访问和修改值
- 输出各级指针的地址和值

**预期输出格式**：
```
=== 任务4: 多级指针操作 ===
value = 100, 地址 = 0x...
ptr 指向 0x..., *ptr = 100
pptr 指向 0x..., **pptr = 100
通过**pptr修改后, value = 200
```

### 任务5：动态内存管理（20分）

实现 `DynamicArray` 结构体和相关函数：
- `createArray(int size)`: 创建指定大小的动态数组
- `initArray(DynamicArray* arr)`: 用索引值初始化数组
- `printArray(const DynamicArray* arr)`: 打印数组
- `resizeArray(DynamicArray* arr, int newSize)`: 调整数组大小
- `destroyArray(DynamicArray* arr)`: 释放内存

**预期输出格式**：
```
=== 任务5: 动态内存管理 ===
创建大小为5的动态数组
数组内容: [0, 1, 2, 3, 4]
调整大小为8
数组内容: [0, 1, 2, 3, 4, 0, 0, 0]
调整大小为3
数组内容: [0, 1, 2]
释放内存完成
```

### 任务6：const指针详解（10分）

实现 `constPointerDemo()` 函数：
- 演示指向常量的指针
- 演示常量指针
- 演示指向常量的常量指针
- 说明各种情况下什么操作是允许的

**预期输出格式**：
```
=== 任务6: const指针详解 ===

1. 指向常量的指针 (const int* p):
   初始值: 10
   改变指向后: 20
   (不能通过指针修改值，但可以改变指向)

2. 常量指针 (int* const p):
   初始值: 30
   修改值后: 40
   (可以修改值，但不能改变指向)

3. 指向常量的常量指针 (const int* const p):
   值: 50
   (既不能修改值，也不能改变指向)
```

### 任务7：内存安全检查（15分）

实现 `memorySafetyDemo()` 函数：
- 演示正确的内存分配和释放流程
- 展示如何避免悬空指针
- 实现安全的指针操作函数 `safeDelete`

**预期输出格式**：
```
=== 任务7: 内存安全检查 ===

正确的内存管理流程:
1. 分配内存: ptr = new int(42)
2. 使用内存: *ptr = 42
3. 释放内存: delete ptr
4. 置空指针: ptr = nullptr

安全删除函数测试:
删除前: ptr != nullptr
安全删除后: ptr == nullptr
再次安全删除: 安全（对nullptr无操作）

动态数组安全管理:
分配: arr = new int[5]
初始化: 0 1 2 3 4
释放: delete[] arr
置空: arr = nullptr
```

---

## 评分标准

| 任务 | 分值 | 评分要点 |
|------|------|----------|
| 任务1 | 15分 | 正确使用&和*运算符，输出格式正确 |
| 任务2 | 15分 | 指针遍历正确，求和与最大值计算正确 |
| 任务3 | 15分 | 指针算术运算正确，比较运算使用恰当 |
| 任务4 | 10分 | 多级指针定义和使用正确 |
| 任务5 | 20分 | 动态内存分配/释放正确，无内存泄漏 |
| 任务6 | 10分 | const与指针组合理解正确 |
| 任务7 | 15分 | 内存安全意识强，代码无安全隐患 |

**总分：100分**

### 扣分项
- 内存泄漏：每处 -5分
- 悬空指针未处理：每处 -3分
- new/delete不配对：每处 -5分
- 野指针使用：每处 -5分
- 输出格式不符：每处 -1分

---

## 编译与测试

```bash
# 编译
g++ -std=c++11 -Wall -o memory_lab submit.cpp

# 运行
./memory_lab

# 内存检查（Linux/Mac，如果有valgrind）
valgrind --leak-check=full ./memory_lab
```

---

## 提示与建议

1. **始终初始化指针**：声明指针时立即初始化为nullptr或有效地址
2. **配对使用new/delete**：new配delete，new[]配delete[]
3. **释放后置空**：delete后立即将指针设为nullptr
4. **检查空指针**：使用指针前检查是否为nullptr
5. **理解指针算术**：指针加减的单位是元素大小，不是字节
6. **const位置很重要**：记住"左定值，右定向"的规则

---

## 扩展思考

1. 为什么数组名不能被赋值？（`arr = ptr;` 为什么错误？）
2. `int* p, q;` 定义了几个指针？为什么？
3. 函数返回局部变量的指针有什么问题？
4. 智能指针如何解决手动内存管理的问题？

---

## 参考资料

- C++ Primer 第5版 第2章（变量和基本类型）
- C++ Primer 第5版 第12章（动态内存）
- cppreference.com - Pointer declaration
- cppreference.com - new expression
