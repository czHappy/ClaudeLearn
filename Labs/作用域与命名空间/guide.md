# 实验指导书：模块化游戏系统

## 实验目标
通过设计一个模块化的游戏系统，掌握C++中作用域与命名空间的核心概念和实践应用。

## 知识点清单
本实验涵盖以下知识点：
- 局部作用域与全局作用域
- 块作用域与变量生命周期
- 静态局部变量(static)
- namespace 定义与使用
- using 声明与 using 指令
- 作用域解析运算符(::)
- 作用域就近原则

## 实验背景
你正在开发一个游戏引擎，需要将不同的功能模块化管理。游戏系统包含三个主要模块：
- **Graphics**：图形渲染模块
- **Audio**：音频播放模块
- **Physics**：物理引擎模块

每个模块都有自己的命名空间，以避免命名冲突。同时，系统需要使用全局变量、局部变量、静态变量等不同作用域的变量来管理游戏状态。

## 实验任务

### 任务1：定义命名空间结构（25分）
创建三个命名空间：Graphics、Audio、Physics，每个命名空间包含：
- 一个 `initialize()` 函数
- 一个 `update()` 函数
- 至少一个模块特定的函数

要求：
- Graphics命名空间：包含 `render()` 函数用于渲染
- Audio命名空间：包含 `playSound()` 函数用于播放声音
- Physics命名空间：包含 `simulate()` 函数用于物理模拟

### 任务2：实现全局与局部作用域（20分）
- 定义全局变量 `gameRunning` (bool类型) 表示游戏是否运行
- 定义全局常量 `MAX_FPS` (int类型) 表示最大帧率
- 在函数中使用局部变量，并演示局部变量的生命周期

### 任务3：使用静态局部变量（15分）
实现一个 `getFrameCount()` 函数，使用静态局部变量统计游戏运行的总帧数。每次调用该函数时，帧数自动增加1并返回当前帧数。

### 任务4：作用域解析运算符的使用（20分）
- 在不同命名空间中定义同名变量或函数
- 使用作用域解析运算符 `::` 访问特定命名空间中的成员
- 演示全局作用域运算符 `::` 的使用（访问被遮蔽的全局变量）

### 任务5：using声明与using指令（10分）
- 使用 `using` 声明引入特定的命名空间成员
- 使用 `using namespace` 指令引入整个命名空间
- 对比两者的区别和适用场景

### 任务6：作用域就近原则与块作用域（10分）
- 在嵌套的块作用域中定义同名变量
- 演示变量的遮蔽效果和就近原则
- 展示块作用域结束后变量的销毁

## 输入输出示例

### 示例输入
程序无需用户输入，自动运行游戏系统的初始化和更新流程。

### 示例输出
```
=== 游戏系统启动 ===
最大FPS: 60
游戏状态: 运行中

--- 初始化各模块 ---
[Graphics] 图形模块初始化完成
[Audio] 音频模块初始化完成
[Physics] 物理模块初始化完成

--- 游戏主循环 (3帧演示) ---
第 1 帧:
  [Graphics] 渲染场景...
  [Audio] 播放背景音乐
  [Physics] 物理模拟: 重力 = 9.8

第 2 帧:
  [Graphics] 渲染场景...
  [Audio] 播放背景音乐
  [Physics] 物理模拟: 重力 = 9.8

第 3 帧:
  [Graphics] 渲染场景...
  [Audio] 播放背景音乐
  [Physics] 物理模拟: 重力 = 9.8

--- 作用域演示 ---
外层作用域: 玩家ID = 1001
  内层作用域: 玩家ID = 2002 (局部变量遮蔽)
  使用全局作用域: 玩家ID = 1001
返回外层作用域: 玩家ID = 1001

--- 静态变量演示 ---
调用统计: 第 1 次
调用统计: 第 2 次
调用统计: 第 3 次

--- 命名空间冲突解决 ---
Graphics::version = 1.0
Audio::version = 2.0
Physics::version = 1.5

=== 游戏系统关闭 ===
总运行帧数: 3
```

## 评分标准

### 基础功能（60分）
- 命名空间定义完整且结构清晰（25分）
- 全局变量和局部变量使用正确（20分）
- 静态局部变量实现正确（15分）

### 高级特性（30分）
- 作用域解析运算符使用得当（20分）
- using声明和指令使用正确（10分）

### 代码质量（10分）
- 代码规范，注释清晰（5分）
- 输出格式美观，易于理解（5分）

## 实验提示

### 提示1：命名空间嵌套
可以在命名空间内部再定义嵌套的命名空间，例如：
```cpp
namespace Graphics {
    namespace OpenGL {
        void render() { /* ... */ }
    }
}
```

### 提示2：匿名命名空间
使用匿名命名空间限制变量或函数的作用域到当前文件：
```cpp
namespace {
    int internalCounter = 0;  // 仅在当前文件可见
}
```

### 提示3：作用域运算符访问全局变量
当局部变量与全局变量同名时，使用 `::` 访问全局变量：
```cpp
int value = 100;  // 全局变量

void func() {
    int value = 200;  // 局部变量
    cout << value;     // 输出 200
    cout << ::value;   // 输出 100 (全局变量)
}
```

### 提示4：静态局部变量的初始化
静态局部变量只在第一次执行到声明时初始化，之后保持其值：
```cpp
void counter() {
    static int count = 0;  // 只初始化一次
    count++;
    cout << count << endl;
}
```

## 扩展挑战（选做）
1. 实现命名空间别名，简化长命名空间的使用
2. 使用嵌套命名空间组织更复杂的模块结构
3. 实现一个使用匿名命名空间的内部辅助函数
4. 创建一个全局的资源管理器，使用静态变量跟踪资源分配

## 注意事项
1. 避免滥用 `using namespace`，特别是在头文件中
2. 合理使用全局变量，避免过度依赖全局状态
3. 静态局部变量适用于需要在函数调用间保持状态的场景
4. 注意变量的生命周期和作用域范围，避免访问已销毁的变量
5. 使用有意义的命名空间名称，体现模块功能

## 参考资料
- C++ Primer (第5版) 第18章
- Effective C++ 条款2：尽量以const, enum, inline替换#define
- C++命名空间最佳实践指南
