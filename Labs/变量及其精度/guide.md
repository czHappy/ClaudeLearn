# 实验2：变量及其精度 - 数据侦探

## 实验目标
通过探索不同数据类型的边界、精度和行为，深入理解C++中变量类型的特性和陷阱。

## 知识点清单
- [x] 基本数据类型（int, float, double, char, bool）
- [x] 整型的不同宽度（short, int, long, long long）
- [x] 有符号与无符号类型（signed vs unsigned）
- [x] 浮点数精度问题与比较陷阱
- [x] 类型转换（隐式转换、显式转换）
- [x] 数值溢出与未定义行为
- [x] sizeof 运算符与类型大小

## 实验背景
作为一名"数据侦探"，你需要调查各种数据类型的秘密，发现它们的边界和陷阱。这些知识对于编写健壮的程序至关重要。

## 实验任务

### 任务1：类型大小探测器（sizeof）
编写程序显示各种数据类型的大小：
- 基本类型：char, bool, short, int, long, long long
- 浮点类型：float, double, long double
- 无符号类型与对应的有符号类型大小对比

### 任务2：整型边界探索
探索不同整型的范围：
- 使用 `<climits>` 头文件中的常量（INT_MAX, INT_MIN 等）
- 手动计算范围：对于n位有符号整数，范围是 [-2^(n-1), 2^(n-1)-1]
- 验证 unsigned 类型的范围 [0, 2^n-1]

### 任务3：整数溢出实验
演示整数溢出的现象：
- 有符号整数溢出（未定义行为）
- 无符号整数回绕（定义良好的行为）
- 检测并预防溢出的方法

### 任务4：浮点精度陷阱
探索浮点数的精度问题：
- 演示 0.1 + 0.2 != 0.3 的问题
- float 与 double 精度对比
- 实现安全的浮点数比较函数（使用 epsilon）
- 大数加小数时的精度丢失

### 任务5：类型转换探险
实验不同类型之间的转换：
- 隐式转换的规则（整型提升、算术转换）
- 有符号与无符号混合运算的陷阱
- 浮点到整型的截断
- 显式类型转换的使用

### 任务6：有符号与无符号的陷阱
探索 signed 和 unsigned 混合使用的危险：
- 负数转换为 unsigned 的结果
- 循环计数器的陷阱
- 比较运算中的隐式转换

## 输入输出示例

### 示例1：类型大小
```
=== 数据类型大小探测 ===
类型             大小(字节)    范围
-------------------------------------------
char                1         -128 ~ 127
unsigned char       1         0 ~ 255
short               2         -32768 ~ 32767
int                 4         -2147483648 ~ 2147483647
long                4         -2147483648 ~ 2147483647
long long           8         -9223372036854775808 ~ 9223372036854775807
float               4         精度约6-7位有效数字
double              8         精度约15-16位有效数字
```

### 示例2：整数溢出
```
=== 整数溢出实验 ===
INT_MAX = 2147483647
INT_MAX + 1 = -2147483648 (溢出！有符号整数溢出是未定义行为)

UINT_MAX = 4294967295
UINT_MAX + 1 = 0 (回绕！无符号整数回绕是定义良好的)
```

### 示例3：浮点精度
```
=== 浮点精度陷阱 ===
0.1 + 0.2 = 0.30000000000000004
0.1 + 0.2 == 0.3? 否！

float精度测试：
1234567.0f + 0.1f = 1234567.0 (小数丢失!)

安全比较：
使用epsilon比较: 0.1+0.2 ≈ 0.3? 是
```

### 示例4：类型转换陷阱
```
=== 类型转换探险 ===
int a = -1;
unsigned int b = 1;
比较 a < b 的结果: false! (因为a被转换为很大的unsigned值)

-1 转换为 unsigned: 4294967295

double转int: 3.9 -> 3 (截断而非四舍五入)
```

## 评分标准
1. 类型大小探测完整（15分）
2. 整型边界探索正确（15分）
3. 溢出演示清晰（20分）
4. 浮点精度实验完整（20分）
5. 类型转换演示正确（20分）
6. 代码规范、注释清晰（10分）

## 提示
1. 使用 `<climits>` 获取整型范围常量
2. 使用 `<cfloat>` 获取浮点型精度常量
3. 使用 `<iomanip>` 中的 `setprecision` 控制输出精度
4. 浮点比较通常使用相对误差或绝对误差
5. 注意：有符号整数溢出是未定义行为，结果不可预测

## 思考题
1. 为什么浮点数不能精确表示 0.1？
2. 为什么 `sizeof(char)` 总是 1？
3. 在循环中使用 unsigned 计数器向下计数到 0 会有什么问题？
4. 如何安全地检测整数加法是否会溢出？
