# 实验：位运算魔法师

## 实验背景

在计算机的世界里，一切数据最终都以二进制形式存储和处理。位运算直接操作二进制位，是最接近硬件的操作方式，具有极高的执行效率。掌握位运算不仅能写出更高效的代码，还能深入理解计算机的工作原理。

本实验将带你探索位运算的奥秘，从基础的进制转换到高级的位运算技巧，让你成为真正的"位运算魔法师"！

## 知识点概览

### 1. 二进制表示与进制转换

#### 常用进制

| 进制 | 基数 | 数字范围 | C++前缀 | 示例 |
|------|------|----------|---------|------|
| 二进制 | 2 | 0-1 | 0b | 0b1010 = 10 |
| 八进制 | 8 | 0-7 | 0 | 012 = 10 |
| 十进制 | 10 | 0-9 | 无 | 10 |
| 十六进制 | 16 | 0-9, A-F | 0x | 0xA = 10 |

#### 进制转换原理

**十进制转R进制**：除R取余，逆序排列
```
例：13转二进制
13 ÷ 2 = 6 ... 1
 6 ÷ 2 = 3 ... 0
 3 ÷ 2 = 1 ... 1
 1 ÷ 2 = 0 ... 1
结果：1101
```

**R进制转十进制**：按权展开求和
```
例：1101(二进制) = 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8+4+0+1 = 13
```

### 2. 位运算符

C++提供6种位运算符：

| 运算符 | 名称 | 功能 | 示例 |
|--------|------|------|------|
| `&` | 按位与 | 两位都为1才为1 | `5 & 3 = 1` (101 & 011 = 001) |
| `\|` | 按位或 | 有一位为1就为1 | `5 \| 3 = 7` (101 \| 011 = 111) |
| `^` | 按位异或 | 两位不同为1 | `5 ^ 3 = 6` (101 ^ 011 = 110) |
| `~` | 按位取反 | 0变1，1变0 | `~5 = -6` |
| `<<` | 左移 | 左移n位，低位补0 | `5 << 1 = 10` |
| `>>` | 右移 | 右移n位 | `5 >> 1 = 2` |

#### 运算符真值表

```
按位与 &        按位或 |        按位异或 ^
A B | A&B      A B | A|B       A B | A^B
0 0 |  0       0 0 |  0        0 0 |  0
0 1 |  0       0 1 |  1        0 1 |  1
1 0 |  0       1 0 |  1        1 0 |  1
1 1 |  1       1 1 |  1        1 1 |  0
```

### 3. 位掩码（Bit Mask）技术

位掩码是一种用二进制位表示多个布尔状态的技术。

#### 基本操作

```cpp
// 设置第n位为1
x |= (1 << n);

// 清除第n位为0
x &= ~(1 << n);

// 切换第n位
x ^= (1 << n);

// 检查第n位是否为1
bool isSet = (x >> n) & 1;
// 或者
bool isSet = x & (1 << n);
```

#### 权限管理示例

```cpp
const int READ    = 1;      // 0001
const int WRITE   = 2;      // 0010
const int EXECUTE = 4;      // 0100
const int DELETE  = 8;      // 1000

int userPermission = READ | WRITE;  // 0011，拥有读写权限

// 检查权限
if (userPermission & READ) {
    cout << "有读权限" << endl;
}

// 添加权限
userPermission |= EXECUTE;  // 0111

// 移除权限
userPermission &= ~WRITE;   // 0101
```

### 4. 位运算实现算术运算

#### 加法原理

```cpp
// 不用+号实现加法
int add(int a, int b) {
    while (b != 0) {
        int carry = (a & b) << 1;  // 进位
        a = a ^ b;                  // 不进位的和
        b = carry;
    }
    return a;
}
```

**原理解释**：
- `a ^ b`：计算不考虑进位的和
- `(a & b) << 1`：计算进位
- 循环直到没有进位

#### 乘法原理

```cpp
// 位运算实现乘法（正整数）
int multiply(int a, int b) {
    int result = 0;
    while (b > 0) {
        if (b & 1) {           // b的最低位是1
            result += a;       // 加上a
        }
        a <<= 1;               // a左移（相当于×2）
        b >>= 1;               // b右移（检查下一位）
    }
    return result;
}
```

### 5. 位运算常见技巧

#### 判断奇偶

```cpp
// 最低位为1是奇数，为0是偶数
bool isOdd = n & 1;
bool isEven = !(n & 1);
```

#### 交换两个数

```cpp
// 不使用临时变量
a ^= b;
b ^= a;
a ^= b;
// 原理：a^b^b = a, a^b^a = b
```

#### 判断2的幂次

```cpp
// 2的幂次只有一个1
bool isPowerOfTwo = n > 0 && (n & (n - 1)) == 0;

/*
例：8 = 1000
    7 = 0111
8 & 7 = 0000 ✓

例：6 = 0110
    5 = 0101
6 & 5 = 0100 ✗
*/
```

#### 获取最低位的1

```cpp
int lowestBit = n & (-n);
// 或
int lowestBit = n & (~n + 1);
```

#### 清除最低位的1

```cpp
n = n & (n - 1);
```

#### 统计1的个数

```cpp
int count = 0;
while (n) {
    n &= (n - 1);  // 每次清除最低位的1
    count++;
}
```

### 6. 整数的补码表示

计算机使用**补码**存储有符号整数：

- **正数**：补码 = 原码
- **负数**：补码 = 反码 + 1 = ~|x| + 1

```
+5 的补码（8位）：0000 0101
-5 的补码（8位）：1111 1011

计算 -5 的补码：
原码：1000 0101 （最高位是符号位）
反码：1111 1010 （符号位不变，其他取反）
补码：1111 1011 （反码+1）
```

**补码的优点**：
1. 加减法统一处理
2. 0的表示唯一
3. 比原码多表示一个负数

### 7. 位域（Bit Field）

位域允许在结构体中按位分配空间：

```cpp
struct PackedData {
    unsigned int flag : 1;      // 1位，0或1
    unsigned int type : 4;      // 4位，0-15
    unsigned int value : 11;    // 11位，0-2047
};  // 总共16位 = 2字节

// 使用
PackedData data;
data.flag = 1;
data.type = 5;
data.value = 1000;
```

**应用场景**：
- 网络协议头部
- 文件格式解析
- 硬件寄存器
- 压缩存储

---

## 实验任务

### 任务1：进制转换（15分）

实现三个进制转换函数，将十进制正整数转换为二进制、八进制、十六进制字符串。

**要求**：
- 不使用标准库的进制转换功能
- 处理输入为0的情况

### 任务2：基本位运算演示（10分）

编写函数展示所有位运算符的效果，对两个8位整数进行各种位运算并显示结果。

**输出格式**：
```
a = 12, 二进制: 00001100
b = 10, 二进制: 00001010
a & b = 8, 二进制: 00001000
...
```

### 任务3：位运算技巧（20分）

实现以下函数：
1. `isOdd(int n)` - 判断奇偶
2. `swapWithXor(int& a, int& b)` - 异或交换
3. `isPowerOfTwo(int n)` - 判断是否为2的幂
4. `countSetBits(int n)` - 统计二进制中1的个数
5. `getLowestSetBit(int n)` - 获取最低位的1

### 任务4：权限管理系统（20分）

使用位掩码设计一个简单的权限管理系统：
- 定义权限常量：READ, WRITE, EXECUTE, DELETE
- 实现权限的添加、移除、检查功能
- 实现权限的字符串表示（如 "rwx-"）

### 任务5：位运算实现算术（20分）

只使用位运算实现：
1. `bitwiseAdd(int a, int b)` - 加法
2. `bitwiseMultiply(int a, int b)` - 乘法（正整数）

### 任务6：紧凑日期存储（15分）

使用位域设计一个紧凑的日期结构体，要求：
- 年份：0-127（表示2000-2127年）占7位
- 月份：1-12 占4位
- 日期：1-31 占5位
- 整个结构体只占2字节（16位）

实现日期的设置、读取和格式化输出功能。

---

## 评分标准

| 任务 | 分值 | 评分要点 |
|------|------|----------|
| 任务1 | 15分 | 转换正确(9分)、边界处理(3分)、代码规范(3分) |
| 任务2 | 10分 | 运算正确(6分)、格式美观(4分) |
| 任务3 | 20分 | 每个函数4分 |
| 任务4 | 20分 | 权限定义(4分)、操作实现(12分)、字符串表示(4分) |
| 任务5 | 20分 | 加法(8分)、乘法(12分) |
| 任务6 | 15分 | 结构定义(5分)、功能实现(7分)、大小正确(3分) |

---

## 思考题

1. 为什么 `n & (n-1)` 能清除最低位的1？请画图解释。

2. 异或运算有哪些有趣的性质？为什么可以用于交换变量？

3. 在什么情况下，位运算比算术运算更有优势？

4. 补码表示法中，为什么 `-1` 的二进制全是1？

5. 位域在不同平台上可能有什么问题？如何保证跨平台兼容性？

---

## 参考资料

- 《深入理解计算机系统》第2章 - 信息的表示和处理
- 《Hacker's Delight》 - 位运算技巧大全
- [Bit Twiddling Hacks](https://graphics.stanford.edu/~seander/bithacks.html)

---

## 附录：常用位运算速查表

| 操作 | 代码 | 说明 |
|------|------|------|
| 设置第n位 | `x \|= (1 << n)` | 将第n位置1 |
| 清除第n位 | `x &= ~(1 << n)` | 将第n位置0 |
| 切换第n位 | `x ^= (1 << n)` | 第n位取反 |
| 检查第n位 | `(x >> n) & 1` | 返回0或1 |
| 清除最低位1 | `x & (x - 1)` | |
| 获取最低位1 | `x & (-x)` | |
| 判断2的幂 | `x && !(x & (x-1))` | |
| 判断奇数 | `x & 1` | |
| 乘以2^n | `x << n` | |
| 除以2^n | `x >> n` | 正数 |
| 取模2^n | `x & ((1 << n) - 1)` | |
